<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>営業日カレンダー - 素土</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: '游明朝', 'Yu Mincho', 'Hiragino Mincho ProN', 'MS Mincho', serif;
            background: #ffffff;
            padding: 40px;
            color: #333;
            font-weight: 300;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        .settings-button {
            position: fixed;
            top: 30px;
            right: 30px;
            background: #1976d2;
            color: white;
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            font-size: 1.2rem;
            cursor: pointer;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .instagram-button {
            position: fixed;
            top: 30px;
            right: 90px;
            background: linear-gradient(135deg, #833ab4, #fd1d1d, #fcb045);
            color: white;
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            font-size: 1.2rem;
            cursor: pointer;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .instagram-button:hover {
            transform: scale(1.1);
            transition: transform 0.3s ease;
        }

        .settings-modal, .instagram-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1001;
        }

        .settings-content, .instagram-content {
            background: white;
            padding: 40px;
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            width: 550px;
            max-height: 90vh;
            overflow-y: auto;
        }

        .instagram-content {
            width: 500px;
        }

        .settings-title, .instagram-title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 30px;
            text-align: center;
            color: #333;
        }

        .instagram-title {
            background: linear-gradient(135deg, #833ab4, #fd1d1d, #fcb045);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-label {
            display: block;
            margin-bottom: 8px;
            font-size: 1rem;
            color: #6c757d;
            font-family: '游明朝', 'Yu Mincho', 'Hiragino Mincho ProN', 'MS Mincho', serif;
        }

        .form-select, .form-input {
            width: 100%;
            padding: 12px;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            font-size: 1rem;
            font-family: '游明朝', 'Yu Mincho', 'Hiragino Mincho ProN', 'MS Mincho', serif;
        }

        .marker-settings {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .marker-settings-header {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #dee2e6;
        }

        .marker-settings-title {
            font-size: 0.85rem;
            color: #6c757d;
            text-align: center;
        }

        .marker-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
            padding: 10px;
            background: white;
            border-radius: 8px;
            position: relative;
        }

        .marker-item.removable {
            padding-right: 50px;
        }

        .marker-preview {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 2px solid #fff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .marker-label-input {
            flex: 1;
            padding: 8px;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            font-size: 0.9rem;
            font-family: '游明朝', 'Yu Mincho', 'Hiragino Mincho ProN', 'MS Mincho', serif;
        }

        .marker-color-input {
            width: 50px;
            height: 35px;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            cursor: pointer;
        }

        .remove-marker-btn {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 50%;
            width: 28px;
            height: 28px;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }

        .remove-marker-btn:hover {
            background: #c82333;
            transform: translateY(-50%) scale(1.1);
        }

        .add-marker-btn {
            width: 100%;
            padding: 12px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 10px;
        }

        .add-marker-btn:hover {
            background: #218838;
        }

        .add-marker-btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .color-section {
            display: flex;
            align-items: center;
            gap: 20px;
            min-height: 60px;
        }

        .color-input {
            width: 60px;
            height: 60px;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            cursor: pointer;
            padding: 0;
        }

        .color-preview {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .preview-color {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            border: 1px solid rgba(0,0,0,0.1);
            cursor: help;
            position: relative;
        }

        .preview-color:hover::after {
            content: attr(title);
            position: absolute;
            bottom: -25px;
            left: 50%;
            transform: translateX(-50%);
            background: #333;
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            white-space: nowrap;
            z-index: 10;
        }

        .form-buttons {
            display: flex;
            gap: 10px;
            justify-content: space-between;
            margin-top: 30px;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            cursor: pointer;
            font-family: '游明朝', 'Yu Mincho', 'Hiragino Mincho ProN', 'MS Mincho', serif;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: #1976d2;
            color: white;
        }

        .btn-secondary {
            background: #dee2e6;
            color: #6c757d;
        }

        .btn-instagram {
            background: linear-gradient(135deg, #833ab4, #fd1d1d, #fcb045);
            color: white;
            width: 100%;
        }

        .btn-instagram:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(131, 58, 180, 0.4);
        }

        .preview-container {
            margin: 20px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 12px;
            display: flex;
            justify-content: center;
        }

        .preview-canvas {
            max-width: 100%;
            max-height: 400px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .background-options {
            display: grid;
            grid-template-columns: repeat(6, 50px);
            grid-template-rows: repeat(2, 50px);
            gap: 8px;
            margin-top: 10px;
            width: 100%;
            justify-content: center;
        }

        .bg-option {
            width: 50px;
            height: 50px;
            border-radius: 8px;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.3s ease;
            box-sizing: border-box;
        }

        .bg-option:hover {
            transform: scale(1.05);
        }

        .bg-option.selected {
            border-color: #1976d2;
            box-shadow: 0 0 0 2px rgba(25, 118, 210, 0.2);
        }

        .calendar-container {
            width: 900px;
            height: 1125px;
            background: white;
            position: relative;
        }

        .calendar-inner {
            width: 100%;
            height: 100%;
            position: relative;
        }

        .month-number {
            position: absolute;
            left: 75px;
            top: 100px;
            font-size: 180px;
            font-weight: 300;
            line-height: 1;
        }

        .header-info {
            position: absolute;
            right: 75px;
            top: 100px;
            max-width: 300px;
        }

        .month-title {
            font-size: 54px;
            font-weight: 400;
            text-align: right;
            letter-spacing: 0;
            margin-bottom: 0;
        }

        .year {
            font-size: 48px;
            font-weight: 300;
            opacity: 0.7;
            text-align: right;
            letter-spacing: 2px;
            margin-bottom: 0;
        }

        .legend {
            margin-top: 0;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 14px;
            margin-bottom: 0;
            justify-content: flex-end;
        }

        .legend-color {
            width: 34px;
            height: 34px;
            border-radius: 50%;
            border: 2px solid #fff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .legend-text {
            font-size: 30px;
            font-weight: 400;
            letter-spacing: 0;
        }

        .calendar-grid {
            position: absolute;
            left: 75px;
            top: 440px;
            width: 750px;
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 0;
        }

        .day-header {
            width: 107px;
            height: 67px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            font-weight: 400;
            letter-spacing: 3px;
            opacity: 0.8;
        }

        .day {
            width: 107px;
            height: 90px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 44px;
            font-weight: 300;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .day:hover {
            transform: scale(1.05);
        }

        .day.other-month {
            cursor: default;
        }

        .day.other-month:hover {
            background: none;
            transform: none;
        }

        @keyframes markerChange {
            0% {
                transform: scale(1);
            }
            50% {
                transform: scale(0.9);
            }
            100% {
                transform: scale(1);
            }
        }

        .day.transitioning {
            animation: markerChange 0.3s ease;
        }
    </style>
</head>
<body>
    <button class="settings-button" id="settingsButton">⚙</button>
    <button class="instagram-button" id="instagramButton">📷</button>
    
    <div class="settings-modal" id="settingsModal">
        <div class="settings-content">
            <div class="settings-title">カレンダー設定</div>
            
            <div class="form-group">
                <label class="form-label">年</label>
                <select class="form-select" id="yearSelect"></select>
            </div>
            
            <div class="form-group">
                <label class="form-label">月</label>
                <select class="form-select" id="monthSelect">
                    <option value="0" selected>1月</option>
                    <option value="1">2月</option>
                    <option value="2">3月</option>
                    <option value="3">4月</option>
                    <option value="4">5月</option>
                    <option value="5">6月</option>
                    <option value="6">7月</option>
                    <option value="7">8月</option>
                    <option value="8">9月</option>
                    <option value="9">10月</option>
                    <option value="10">11月</option>
                    <option value="11">12月</option>
                </select>
            </div>
            
            <div class="form-group">
                <label class="form-label">テーマカラー</label>
                <div class="color-section">
                    <input type="color" class="color-input" id="baseColorInput" value="#000000">
                    <div class="color-preview">
                        <div class="preview-color" id="previewPrimary" style="background: #000000;" title="メインカラー"></div>
                        <div class="preview-color" id="previewAccent" style="background: #e0e0e0;" title="営業日マーカー"></div>
                        <div class="preview-color" id="previewDark" style="background: #d0d0d0;" title="ホバー時"></div>
                    </div>
                </div>
            </div>

            <div class="form-group">
                <label class="form-label">マーカー設定</label>
                <div class="marker-settings" id="markerSettingsContainer">
                </div>
                <button class="add-marker-btn" id="addMarkerBtn">+ マーカーを追加</button>
            </div>
            
            <div class="form-buttons">
                <button class="btn btn-secondary" id="cancelButton">キャンセル</button>
                <button class="btn btn-primary" id="applyButton">適用</button>
            </div>
        </div>
    </div>

    <div class="instagram-modal" id="instagramModal">
        <div class="instagram-content">
            <div class="instagram-title">Instagram用画像エクスポート</div>
            
            <div class="form-group">
                <label class="form-label">背景色</label>
                <div class="background-options">
                    <div class="bg-option selected" data-bg="#ffffff" style="background: #ffffff; border: 1px solid #dee2e6;" title="純白"></div>
                    <div class="bg-option" data-bg="#fff0f5" style="background: #fff0f5;" title="桜色"></div>
                    <div class="bg-option" data-bg="#fff9e6" style="background: #fff9e6;" title="淡黄"></div>
                    <div class="bg-option" data-bg="#f0fbe8" style="background: #f0fbe8;" title="若葉"></div>
                    <div class="bg-option" data-bg="#e6f4ff" style="background: #e6f4ff;" title="水浅葱"></div>
                    <div class="bg-option" data-bg="#f0e6ff" style="background: #f0e6ff;" title="薄紫"></div>
                    <div class="bg-option" data-bg="#fff5ee" style="background: #fff5ee;" title="生成り"></div>
                    <div class="bg-option" data-bg="#fef0e3" style="background: #fef0e3;" title="杏子"></div>
                    <div class="bg-option" data-bg="#f5e1ce" style="background: #f5e1ce;" title="小麦"></div>
                    <div class="bg-option" data-bg="#ede0d5" style="background: #ede0d5;" title="香色"></div>
                    <div class="bg-option" data-bg="#e5dfe6" style="background: #e5dfe6;" title="淡藤"></div>
                    <div class="bg-option" data-bg="#e0e9e5" style="background: #e0e9e5;" title="白磁"></div>
                </div>
            </div>

            <div class="form-group">
                <label class="form-label">フッターテキスト（任意）</label>
                <input type="text" class="form-input" id="footerText" placeholder="例: @your_instagram_id">
            </div>

            <div class="form-group">
                <label class="form-label">プレビュー</label>
                <div class="preview-container">
                    <canvas id="previewCanvas" class="preview-canvas" width="280" height="350"></canvas>
                </div>
            </div>
            
            <div class="form-buttons">
                <button class="btn btn-secondary" id="cancelInstagram">キャンセル</button>
                <button class="btn btn-instagram" id="exportInstagram">
                    画像をダウンロード (1080×1350px)
                </button>
            </div>
        </div>
    </div>

    <div class="calendar-container">
        <div class="calendar-inner">
            <div class="month-number" id="monthNumber">1</div>
            <div class="header-info">
                <div class="month-title" id="monthTitle">素土</div>
                <div class="year" id="yearDisplay">2025</div>
                <div class="legend" id="legendContainer">
                </div>
            </div>

            <div class="calendar-grid" id="calendarGrid">
            </div>
        </div>
    </div>

    <script>
        let currentYear = 2025;
        let currentMonth = 0;
        let markerData = {};
        let currentColors = {
            primary: '#000000',
            accent: '#e0e0e0',
            hover: '#d0d0d0',
            dark: '#333333',
            markerText: '#000000'
        };
        
        let activeMarkers = {
            1: {
                label: '営業日',
                color: '#c9ddf7',
                textColor: '#1976d2',
                active: true
            }
        };

        let selectedBackground = '#ffffff';
        const storeName = '素土';

        function rgbToHsl(hexColor) {
            const r = parseInt(hexColor.slice(1, 3), 16) / 255;
            const g = parseInt(hexColor.slice(3, 5), 16) / 255;
            const b = parseInt(hexColor.slice(5, 7), 16) / 255;
            
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            const l = (max + min) / 2;
            
            let h, s;
            if (max === min) {
                h = s = 0;
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                
                if (max === r) {
                    h = ((g - b) / d + (g < b ? 6 : 0)) / 6;
                } else if (max === g) {
                    h = ((b - r) / d + 2) / 6;
                } else {
                    h = ((r - g) / d + 4) / 6;
                }
            }
            
            return { h: h * 360, s: s * 100, l: l * 100 };
        }

        function hslToRgb(h, s, l) {
            h = h / 360;
            s = s / 100;
            l = l / 100;
            
            let r, g, b;
            
            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            
            return '#' + [r, g, b].map(x => {
                const hex = Math.round(x * 255).toString(16);
                return hex.length === 1 ? '0' + hex : hex;
            }).join('');
        }

        function generateOptimalMarkerColors(themeColor) {
            const hsl = rgbToHsl(themeColor);
            
            const marker1Saturation = hsl.s > 0 ? Math.max(hsl.s * 0.4, 20) : 0;
            const marker1Lightness = 85;
            const marker1 = hslToRgb(hsl.h, marker1Saturation, marker1Lightness);
            
            const marker1Hsl = rgbToHsl(marker1);
            
            let marker2, marker3;
            if (hsl.s === 0) {
                marker2 = hslToRgb(0, 0, 75);
                marker3 = hslToRgb(0, 0, 65);
            } else {
                const marker2Hue = (marker1Hsl.h + 120) % 360;
                marker2 = hslToRgb(marker2Hue, marker1Hsl.s, marker1Hsl.l);
                
                const marker3Hue = (marker1Hsl.h + 240) % 360;
                marker3 = hslToRgb(marker3Hue, marker1Hsl.s, marker1Hsl.l);
            }
            
            return {
                marker1: marker1,
                marker2: marker2,
                marker3: marker3
            };
        }

        function updateMarkerColorsFromTheme(themeColor) {
            const optimalColors = generateOptimalMarkerColors(themeColor);
            
            if (activeMarkers[1]) {
                activeMarkers[1].color = optimalColors.marker1;
                activeMarkers[1].textColor = themeColor;
            }
            
            if (activeMarkers[2] && activeMarkers[2].active) {
                activeMarkers[2].color = optimalColors.marker2;
                activeMarkers[2].textColor = generateTextColor(optimalColors.marker2);
            }
            
            if (activeMarkers[3] && activeMarkers[3].active) {
                activeMarkers[3].color = optimalColors.marker3;
                activeMarkers[3].textColor = generateTextColor(optimalColors.marker3);
            }
        }

        function generateColors(baseColor) {
            const r = parseInt(baseColor.slice(1, 3), 16);
            const g = parseInt(baseColor.slice(3, 5), 16);
            const b = parseInt(baseColor.slice(5, 7), 16);
            
            const hoverRatio = 0.25;
            const hoverR = Math.round(r * hoverRatio + 255 * (1 - hoverRatio));
            const hoverG = Math.round(g * hoverRatio + 255 * (1 - hoverRatio));
            const hoverB = Math.round(b * hoverRatio + 255 * (1 - hoverRatio));
            const hover = `rgb(${hoverR}, ${hoverG}, ${hoverB})`;

            return {
                primary: baseColor,
                accent: '',
                hover: hover,
                dark: `rgb(${Math.max(0, r - 40)}, ${Math.max(0, g - 40)}, ${Math.max(0, b - 40)})`,
                markerText: baseColor
            };
        }

        function generateLegend() {
            const legendContainer = document.getElementById('legendContainer');
            legendContainer.innerHTML = '';
            
            Object.keys(activeMarkers).forEach(key => {
                if (activeMarkers[key].active) {
                    const marker = activeMarkers[key];
                    const legendItem = document.createElement('div');
                    legendItem.className = 'legend-item';
                    
                    const legendText = document.createElement('div');
                    legendText.className = 'legend-text';
                    legendText.textContent = marker.label;
                    legendText.style.color = currentColors.primary;
                    
                    const legendColor = document.createElement('div');
                    legendColor.className = 'legend-color';
                    legendColor.style.backgroundColor = marker.color;
                    
                    legendItem.appendChild(legendText);
                    legendItem.appendChild(legendColor);
                    legendContainer.appendChild(legendItem);
                }
            });
        }

        function generateCalendar() {
            document.getElementById('monthNumber').textContent = currentMonth + 1;
            document.getElementById('monthTitle').textContent = storeName;
            document.getElementById('yearDisplay').textContent = currentYear;

            generateLegend();

            const grid = document.getElementById('calendarGrid');
            grid.innerHTML = '';

            const dayHeaders = ['SUN', 'MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT'];
            dayHeaders.forEach(headerText => {
                const header = document.createElement('div');
                header.className = 'day-header';
                header.textContent = headerText;
                header.style.color = currentColors.primary;
                grid.appendChild(header);
            });

            const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
            const firstDay = new Date(currentYear, currentMonth, 1).getDay();
            const prevMonthDays = new Date(currentYear, currentMonth, 0).getDate();

            for (let i = firstDay - 1; i >= 0; i--) {
                const day = document.createElement('div');
                day.className = 'day other-month';
                day.textContent = prevMonthDays - i;
                day.style.color = hexToRgba(currentColors.primary, 0.2);
                grid.appendChild(day);
            }

            for (let date = 1; date <= daysInMonth; date++) {
                const day = document.createElement('div');
                day.className = 'day';
                day.textContent = date;
                day.dataset.date = date;
                day.dataset.year = currentYear;
                day.dataset.month = currentMonth;

                const dayKey = `${currentYear}-${currentMonth}-${date}`;
                const markerType = markerData[dayKey];
                if (markerType && activeMarkers[markerType] && activeMarkers[markerType].active) {
                    day.classList.add(`marker-${markerType}`);
                } else if (markerType && (!activeMarkers[markerType] || !activeMarkers[markerType].active)) {
                    delete markerData[dayKey];
                }
                
                if (!markerType || !activeMarkers[markerType] || !activeMarkers[markerType].active) {
                    day.style.color = currentColors.primary;
                }

                day.addEventListener('click', function() {
                    toggleMarker(this);
                });

                grid.appendChild(day);
            }

            const needsSixWeeks = (firstDay + daysInMonth) > 35;
            const totalCells = needsSixWeeks ? 42 : 35;
            const nextMonthDays = totalCells - (firstDay + daysInMonth);
            for (let date = 1; date <= nextMonthDays; date++) {
                const day = document.createElement('div');
                day.className = 'day other-month';
                day.textContent = date;
                day.style.color = hexToRgba(currentColors.primary, 0.2);
                grid.appendChild(day);
            }

            applyMarkerStyles();
        }

        function toggleMarker(element) {
            if (element.classList.contains('other-month')) return;

            element.classList.add('transitioning');
            setTimeout(() => {
                element.classList.remove('transitioning');
            }, 300);

            const year = element.dataset.year;
            const month = element.dataset.month;
            const date = element.dataset.date;
            const dayKey = `${year}-${month}-${date}`;

            const activeMarkerKeys = Object.keys(activeMarkers).filter(key => activeMarkers[key].active).map(Number);
            if (activeMarkerKeys.length === 0) return;

            let currentMarker = markerData[dayKey] || 0;
            
            activeMarkerKeys.forEach(key => {
                element.classList.remove(`marker-${key}`);
            });
            
            let nextMarkerIndex = -1;
            for (let i = 0; i < activeMarkerKeys.length; i++) {
                if (currentMarker < activeMarkerKeys[i]) {
                    nextMarkerIndex = i;
                    break;
                }
            }
            
            if (nextMarkerIndex === -1) {
                delete markerData[dayKey];
                element.style.color = currentColors.primary;
            } else {
                const nextMarker = activeMarkerKeys[nextMarkerIndex];
                markerData[dayKey] = nextMarker;
                element.classList.add(`marker-${nextMarker}`);
                element.style.color = '';
            }
        }

        function applyMarkerStyles() {
            let styleSheet = document.getElementById('dynamic-marker-styles');
            if (!styleSheet) {
                styleSheet = document.createElement('style');
                styleSheet.id = 'dynamic-marker-styles';
                document.head.appendChild(styleSheet);
            }
            
            let styles = '';
            Object.keys(activeMarkers).forEach(key => {
                if (activeMarkers[key].active) {
                    const marker = activeMarkers[key];
                    styles += `
                        .day.marker-${key} {
                            background: radial-gradient(circle at center, ${marker.color} 40px, transparent 40px) !important;
                            color: ${marker.textColor} !important;
                            font-weight: 400 !important;
                        }
                        .day.marker-${key}:hover {
                            background: radial-gradient(circle at center, ${adjustColorBrightness(marker.color, -10)} 40px, transparent 40px) !important;
                        }
                    `;
                }
            });
            
            styleSheet.innerHTML = styles;
        }

        function adjustColorBrightness(color, amount) {
            const usePound = color[0] === "#";
            const col = usePound ? color.slice(1) : color;
            const num = parseInt(col, 16);
            let r = (num >> 16) + amount;
            let g = ((num >> 8) & 0x00FF) + amount;
            let b = (num & 0x0000FF) + amount;
            r = r > 255 ? 255 : r < 0 ? 0 : r;
            g = g > 255 ? 255 : g < 0 ? 0 : g;
            b = b > 255 ? 255 : b < 0 ? 0 : b;
            return (usePound ? "#" : "") + (r << 16 | g << 8 | b).toString(16).padStart(6, '0');
        }

        function generateMarkerSettings() {
            const container = document.getElementById('markerSettingsContainer');
            container.innerHTML = '';
            
            const header = document.createElement('div');
            header.className = 'marker-settings-header';
            
            const title = document.createElement('div');
            title.className = 'marker-settings-title';
            title.textContent = 'テーマカラーを変更すると、マーカーの色も自動的に調整されます';
            
            header.appendChild(title);
            container.appendChild(header);
            
            Object.keys(activeMarkers).forEach(key => {
                if (activeMarkers[key].active) {
                    const marker = activeMarkers[key];
                    const markerItem = document.createElement('div');
                    markerItem.className = key === '1' ? 'marker-item' : 'marker-item removable';
                    
                    const preview = document.createElement('div');
                    preview.className = 'marker-preview';
                    preview.id = `marker${key}Preview`;
                    preview.style.backgroundColor = marker.color;
                    
                    const labelInput = document.createElement('input');
                    labelInput.type = 'text';
                    labelInput.className = 'marker-label-input';
                    labelInput.id = `marker${key}Label`;
                    labelInput.value = marker.label;
                    labelInput.placeholder = `マーカー${key}の名称（例：営業日）`;
                    
                    const colorInput = document.createElement('input');
                    colorInput.type = 'color';
                    colorInput.className = 'marker-color-input';
                    colorInput.id = `marker${key}Color`;
                    colorInput.value = marker.color;
                    
                    colorInput.addEventListener('input', function() {
                        preview.style.backgroundColor = this.value;
                    });
                    
                    markerItem.appendChild(preview);
                    markerItem.appendChild(labelInput);
                    markerItem.appendChild(colorInput);
                    
                    if (key !== '1') {
                        const removeBtn = document.createElement('button');
                        removeBtn.className = 'remove-marker-btn';
                        removeBtn.innerHTML = '×';
                        removeBtn.onclick = () => removeMarker(key);
                        markerItem.appendChild(removeBtn);
                    }
                    
                    container.appendChild(markerItem);
                }
            });
            
            const activeCount = Object.values(activeMarkers).filter(m => m.active).length;
            const addBtn = document.getElementById('addMarkerBtn');
            if (activeCount >= 3) {
                addBtn.disabled = true;
                addBtn.textContent = 'マーカーは最大3つまで';
            } else {
                addBtn.disabled = false;
                addBtn.textContent = '+ マーカーを追加';
            }
        }

        function addMarker() {
            const activeCount = Object.values(activeMarkers).filter(m => m.active).length;
            if (activeCount >= 3) return;
            
            const nextKey = activeCount + 1;
            const optimalColors = generateOptimalMarkerColors(currentColors.primary);
            
            if (nextKey === 2) {
                if (!activeMarkers[2]) {
                    activeMarkers[2] = {
                        label: '会議日',
                        color: optimalColors.marker2,
                        textColor: generateTextColor(optimalColors.marker2),
                        active: true
                    };
                } else {
                    activeMarkers[2].color = optimalColors.marker2;
                    activeMarkers[2].textColor = generateTextColor(optimalColors.marker2);
                    activeMarkers[2].active = true;
                }
            } else if (nextKey === 3) {
                if (!activeMarkers[3]) {
                    activeMarkers[3] = {
                        label: 'イベント',
                        color: optimalColors.marker3,
                        textColor: generateTextColor(optimalColors.marker3),
                        active: true
                    };
                } else {
                    activeMarkers[3].color = optimalColors.marker3;
                    activeMarkers[3].textColor = generateTextColor(optimalColors.marker3);
                    activeMarkers[3].active = true;
                }
            }
            
            generateMarkerSettings();
            applyMarkerStyles();
        }

        function removeMarker(key) {
            activeMarkers[key].active = false;
            
            Object.keys(markerData).forEach(dayKey => {
                if (markerData[dayKey] == key) {
                    delete markerData[dayKey];
                }
            });
            
            generateMarkerSettings();
            generateCalendar();
        }

        // Canvas描画を修正
        function drawInstagramCanvas(canvas, isPreview = false) {
            const ctx = canvas.getContext('2d');
            
            const targetWidth = isPreview ? 280 : 1080;
            const targetHeight = isPreview ? 350 : 1350;
            
            canvas.width = targetWidth;
            canvas.height = targetHeight;
            
            // 背景
            ctx.fillStyle = selectedBackground;
            ctx.fillRect(0, 0, targetWidth, targetHeight);
            
            // スケール計算（オリジナルの900x1125をキャンバスに収める）
            const baseWidth = 900;
            const baseHeight = 1125;
            const scale = Math.min(targetWidth / baseWidth, targetHeight / baseHeight) * 0.9;
            
            // キャンバスの中央に配置するためのオフセット
            const offsetX = (targetWidth - baseWidth * scale) / 2;
            const offsetY = (targetHeight - baseHeight * scale) / 2;
            
            const fontFamily = "'游明朝', 'Yu Mincho', serif";
            
            // 座標変換関数
            const tx = (x) => offsetX + x * scale;
            const ty = (y) => offsetY + y * scale;
            const ts = (size) => size * scale;
            
            // 月の数字（左側）
            ctx.fillStyle = currentColors.primary;
            ctx.font = `300 ${ts(180)}px ${fontFamily}`;
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            ctx.fillText(currentMonth + 1, tx(75), ty(130));  // 100 -> 130 下に移動
            
            // 右側のヘッダー情報のベース位置 - 月の数字と天端を揃える
            const rightBaseX = 825;
            const rightBaseY = 130;  // 100 -> 130 月の数字と同じ高さに
            
            // 店舗名（素土）- 月数字と天端を揃える
            ctx.fillStyle = currentColors.primary;
            ctx.font = `400 ${ts(54)}px ${fontFamily}`;
            ctx.textAlign = 'right';
            ctx.textBaseline = 'top';
            ctx.fillText(storeName, tx(rightBaseX), ty(rightBaseY));
            
            // 年（店舗名の下）
            const verticalSpacing = 85;  // 素土と年の間（元の値）
            ctx.fillStyle = hexToRgba(currentColors.primary, 0.7);
            ctx.font = `300 ${ts(48)}px ${fontFamily}`;
            ctx.textAlign = 'right';
            ctx.textBaseline = 'top';
            ctx.fillText(currentYear.toString(), tx(rightBaseX), ty(rightBaseY + verticalSpacing));
            
            // 凡例（年の下に配置）
            let legendY = rightBaseY + verticalSpacing + 85;  // 年と凡例の間（元の値）
            Object.keys(activeMarkers).forEach(key => {
                if (activeMarkers[key].active) {
                    const marker = activeMarkers[key];
                    
                    // テキストを先に描画（右寄せ）
                    ctx.fillStyle = currentColors.primary;
                    ctx.font = `400 ${ts(30)}px ${fontFamily}`;  // 26 -> 30 (凡例を大きく)
                    ctx.textAlign = 'right';
                    ctx.textBaseline = 'middle';
                    
                    // テキストの幅を測定
                    const textWidth = ctx.measureText(marker.label).width;
                    const textX = rightBaseX - 48;  // マーカー円の分のスペースを確保
                    ctx.fillText(marker.label, tx(textX), ty(legendY));
                    
                    // 円をテキストの右側に描画
                    ctx.fillStyle = marker.color;
                    ctx.beginPath();
                    ctx.arc(tx(rightBaseX - 17), ty(legendY), ts(17), 0, Math.PI * 2);  // 15 -> 17 (凡例の円も大きく)
                    ctx.fill();
                    
                    legendY += 44;  // 38 -> 44 (凡例項目間の間隔を広げる)
                }
            });
            
            // 曜日ヘッダー
            const dayHeaders = ['SUN', 'MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT'];
            ctx.fillStyle = hexToRgba(currentColors.primary, 0.8);
            ctx.font = `400 ${ts(28)}px ${fontFamily}`;  // 23 -> 28
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            const cellWidth = 107;  // 94.3 -> 107
            const cellHeight = 90;  // 行の高さを別に定義
            const gridStartX = 75;  // 120 -> 75
            const gridStartY = 440;  // カレンダーを上に上げる
            
            for (let i = 0; i < 7; i++) {
                const x = gridStartX + (i * cellWidth) + cellWidth/2;
                const y = gridStartY + 33.5;
                ctx.fillText(dayHeaders[i], tx(x), ty(y));
            }
            
            // カレンダーの日付
            const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
            const firstDay = new Date(currentYear, currentMonth, 1).getDay();
            const prevMonthDays = new Date(currentYear, currentMonth, 0).getDate();
            
            let row = 0;
            let col = 0;
            
            // 前月の日付
            ctx.fillStyle = hexToRgba(currentColors.primary, 0.2);
            ctx.font = `300 ${ts(44)}px ${fontFamily}`;  // 38 -> 44
            
            for (let i = firstDay - 1; i >= 0; i--) {
                const x = gridStartX + (col * cellWidth) + cellWidth/2;
                const y = gridStartY + 67 + (row * cellHeight) + cellHeight/2;  // 527 -> gridStartY + 67
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText((prevMonthDays - i).toString(), tx(x), ty(y));
                col++;
            }
            
            // 当月の日付
            for (let date = 1; date <= daysInMonth; date++) {
                if (col === 7) {
                    col = 0;
                    row++;
                }
                
                const x = gridStartX + (col * cellWidth) + cellWidth/2;
                const y = gridStartY + 67 + (row * cellHeight) + cellHeight/2;  // 527 -> gridStartY + 67
                const dayKey = `${currentYear}-${currentMonth}-${date}`;
                const markerType = markerData[dayKey];
                
                if (markerType && activeMarkers[markerType] && activeMarkers[markerType].active) {
                    const marker = activeMarkers[markerType];
                    // マーカーの背景
                    ctx.fillStyle = marker.color;
                    ctx.beginPath();
                    ctx.arc(tx(x), ty(y), ts(40), 0, Math.PI * 2);  // マーカーのサイズを小さく調整
                    ctx.fill();
                    
                    ctx.fillStyle = marker.textColor;
                    ctx.font = `400 ${ts(44)}px ${fontFamily}`;  // 38 -> 44
                } else {
                    ctx.fillStyle = currentColors.primary;
                    ctx.font = `300 ${ts(44)}px ${fontFamily}`;  // 38 -> 44
                }
                
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(date.toString(), tx(x), ty(y));
                col++;
            }
            
            // 来月の日付
            ctx.fillStyle = hexToRgba(currentColors.primary, 0.2);
            ctx.font = `300 ${ts(44)}px ${fontFamily}`;  // 38 -> 44
            
            let nextDate = 1;
            const needsSixWeeks = (firstDay + daysInMonth) > 35;
            const totalCells = needsSixWeeks ? 42 : 35;
            const remainingCells = totalCells - (firstDay + daysInMonth);
            
            for (let i = 0; i < remainingCells; i++) {
                if (col === 7) {
                    col = 0;
                    row++;
                }
                
                const x = gridStartX + (col * cellWidth) + cellWidth/2;
                const y = gridStartY + 67 + (row * cellHeight) + cellHeight/2;  // 527 -> gridStartY + 67
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(nextDate.toString(), tx(x), ty(y));
                nextDate++;
                col++;
            }
            
            // フッター
            const footerText = document.getElementById('footerText').value;
            if (footerText) {
                ctx.fillStyle = hexToRgba(currentColors.primary, 0.6);
                ctx.font = `300 ${ts(30)}px ${fontFamily}`;  // 24 -> 30
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(footerText, targetWidth / 2, targetHeight - ts(60));
            }
        }

        function generatePreview() {
            const canvas = document.getElementById('previewCanvas');
            drawInstagramCanvas(canvas, true);
        }

        function applyColors() {
            const color = currentColors.primary;
            
            document.getElementById('monthNumber').style.color = color;
            document.getElementById('monthTitle').style.color = color;
            document.getElementById('yearDisplay').style.color = color;
            document.getElementById('yearDisplay').style.opacity = '0.7';
            
            document.querySelectorAll('.legend-text').forEach(text => {
                text.style.color = color;
            });
            
            document.querySelectorAll('.day-header').forEach(header => {
                header.style.color = color;
            });
            
            document.querySelectorAll('.day:not(.other-month)').forEach(day => {
                let hasMarker = false;
                Object.keys(activeMarkers).forEach(key => {
                    if (day.classList.contains(`marker-${key}`)) {
                        hasMarker = true;
                        day.style.color = '';
                    }
                });
                if (!hasMarker) {
                    day.style.color = color;
                }
            });
            
            document.querySelectorAll('.day.other-month').forEach(day => {
                day.style.color = hexToRgba(color, 0.2);
            });

            let styleSheet = document.getElementById('dynamic-styles');
            if (!styleSheet) {
                styleSheet = document.createElement('style');
                styleSheet.id = 'dynamic-styles';
                document.head.appendChild(styleSheet);
            }
            
            let notMarkerSelectors = Object.keys(activeMarkers)
                .filter(key => activeMarkers[key].active)
                .map(key => `:not(.marker-${key})`)
                .join('');
            
            styleSheet.innerHTML = `
                .day:not(.other-month)${notMarkerSelectors}:hover {
                    background: radial-gradient(circle at center, ${hexToRgba(color, 0.06)} 40px, transparent 40px) !important;
                }
            `;
        }

        function hexToRgba(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        function generateTextColor(bgColor) {
            const r = parseInt(bgColor.slice(1, 3), 16);
            const g = parseInt(bgColor.slice(3, 5), 16);
            const b = parseInt(bgColor.slice(5, 7), 16);
            
            const brightness = (r * 299 + g * 587 + b * 114) / 1000;
            
            if (brightness > 128) {
                const factor = 0.3;
                return `#${Math.floor(r * factor).toString(16).padStart(2, '0')}${Math.floor(g * factor).toString(16).padStart(2, '0')}${Math.floor(b * factor).toString(16).padStart(2, '0')}`;
            } else {
                return '#ffffff';
            }
        }

        document.addEventListener('DOMContentLoaded', function() {
            currentColors = generateColors('#000000');
            
            const optimalColors = generateOptimalMarkerColors(currentColors.primary);
            
            activeMarkers[1].color = optimalColors.marker1;
            activeMarkers[1].textColor = currentColors.primary;
            
            activeMarkers[2] = {
                label: '会議日',
                color: optimalColors.marker2,
                textColor: generateTextColor(optimalColors.marker2),
                active: false
            };
            
            activeMarkers[3] = {
                label: 'イベント',
                color: optimalColors.marker3,
                textColor: generateTextColor(optimalColors.marker3),
                active: false
            };
            
            const yearSelect = document.getElementById('yearSelect');
            for (let year = 2020; year <= 2035; year++) {
                const option = document.createElement('option');
                option.value = year;
                option.textContent = year + '年';
                if (year === 2025) option.selected = true;
                yearSelect.appendChild(option);
            }

            document.getElementById('settingsButton').addEventListener('click', function() {
                const optimalColors = generateOptimalMarkerColors(currentColors.primary);
                
                activeMarkers[1].color = optimalColors.marker1;
                activeMarkers[1].textColor = currentColors.primary;
                
                if (!activeMarkers[2]) {
                    activeMarkers[2] = {
                        label: '会議日',
                        color: optimalColors.marker2,
                        textColor: generateTextColor(optimalColors.marker2),
                        active: false
                    };
                } else {
                    activeMarkers[2].color = optimalColors.marker2;
                    activeMarkers[2].textColor = generateTextColor(optimalColors.marker2);
                }
                
                if (!activeMarkers[3]) {
                    activeMarkers[3] = {
                        label: 'イベント',
                        color: optimalColors.marker3,
                        textColor: generateTextColor(optimalColors.marker3),
                        active: false
                    };
                } else {
                    activeMarkers[3].color = optimalColors.marker3;
                    activeMarkers[3].textColor = generateTextColor(optimalColors.marker3);
                }
                
                document.getElementById('settingsModal').style.display = 'flex';
                setupColorPicker();
                generateMarkerSettings();
            });

            document.getElementById('addMarkerBtn').addEventListener('click', addMarker);

            document.getElementById('instagramButton').addEventListener('click', function() {
                document.getElementById('instagramModal').style.display = 'flex';
                generatePreview();
            });

            document.querySelectorAll('.bg-option').forEach(option => {
                option.addEventListener('click', function() {
                    document.querySelectorAll('.bg-option').forEach(o => o.classList.remove('selected'));
                    this.classList.add('selected');
                    selectedBackground = this.dataset.bg;
                    generatePreview();
                });
            });

            let footerTimeout;
            document.getElementById('footerText').addEventListener('input', function() {
                clearTimeout(footerTimeout);
                footerTimeout = setTimeout(() => {
                    generatePreview();
                }, 300);
            });

            document.getElementById('exportInstagram').addEventListener('click', function() {
                const canvas = document.createElement('canvas');
                drawInstagramCanvas(canvas, false);
                
                const dataUrl = canvas.toDataURL('image/png');
                const link = document.createElement('a');
                link.download = `calendar_${currentYear}_${String(currentMonth + 1).padStart(2, '0')}_instagram.png`;
                link.href = dataUrl;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            });

            document.getElementById('cancelButton').addEventListener('click', function() {
                document.getElementById('settingsModal').style.display = 'none';
            });

            document.getElementById('cancelInstagram').addEventListener('click', function() {
                document.getElementById('instagramModal').style.display = 'none';
            });

            document.getElementById('applyButton').addEventListener('click', function() {
                const newYear = parseInt(document.getElementById('yearSelect').value);
                const newMonth = parseInt(document.getElementById('monthSelect').value);
                
                if (newYear !== currentYear || newMonth !== currentMonth) {
                    currentYear = newYear;
                    currentMonth = newMonth;
                }

                const newColor = document.getElementById('baseColorInput').value;
                let themeColorChanged = false;
                if (newColor !== currentColors.primary) {
                    currentColors = generateColors(newColor);
                    themeColorChanged = true;
                    updatePreview();
                    
                    const optimalColors = generateOptimalMarkerColors(newColor);
                    
                    activeMarkers[1].color = optimalColors.marker1;
                    activeMarkers[1].textColor = newColor;
                    
                    if (activeMarkers[2]) {
                        activeMarkers[2].color = optimalColors.marker2;
                        activeMarkers[2].textColor = generateTextColor(optimalColors.marker2);
                    }
                    
                    if (activeMarkers[3]) {
                        activeMarkers[3].color = optimalColors.marker3;
                        activeMarkers[3].textColor = generateTextColor(optimalColors.marker3);
                    }
                }
                
                if (!themeColorChanged) {
                    Object.keys(activeMarkers).forEach(key => {
                        if (activeMarkers[key].active) {
                            const labelInput = document.getElementById(`marker${key}Label`);
                            const colorInput = document.getElementById(`marker${key}Color`);
                            
                            if (labelInput) {
                                activeMarkers[key].label = labelInput.value || `マーカー${key}`;
                            }
                            if (colorInput) {
                                activeMarkers[key].color = colorInput.value;
                                if (key === '1') {
                                    activeMarkers[key].textColor = currentColors.primary;
                                } else {
                                    activeMarkers[key].textColor = generateTextColor(colorInput.value);
                                }
                            }
                        }
                    });
                } else {
                    Object.keys(activeMarkers).forEach(key => {
                        if (activeMarkers[key].active) {
                            const labelInput = document.getElementById(`marker${key}Label`);
                            if (labelInput) {
                                activeMarkers[key].label = labelInput.value || `マーカー${key}`;
                            }
                        }
                    });
                }
                
                generateCalendar();
                applyColors();

                document.getElementById('settingsModal').style.display = 'none';
            });

            generateCalendar();
            applyColors();
            
            document.getElementById('monthNumber').style.color = currentColors.primary;
            document.getElementById('monthTitle').style.color = currentColors.primary;
            document.getElementById('yearDisplay').style.color = currentColors.primary;
        });

        function setupColorPicker() {
            const colorInput = document.getElementById('baseColorInput');
            if (!colorInput) return;

            colorInput.value = currentColors.primary;
            
            const optimalColors = generateOptimalMarkerColors(currentColors.primary);
            activeMarkers[1].color = optimalColors.marker1;
            activeMarkers[1].textColor = currentColors.primary;
            
            updatePreview();

            colorInput.addEventListener('input', function() {
                const newColors = generateColors(this.value);
                const optimalColors = generateOptimalMarkerColors(this.value);
                
                document.getElementById('previewPrimary').style.backgroundColor = newColors.primary;
                document.getElementById('previewAccent').style.backgroundColor = optimalColors.marker1;
                document.getElementById('previewDark').style.backgroundColor = newColors.hover;
                
                activeMarkers[1].color = optimalColors.marker1;
                activeMarkers[1].textColor = this.value;
                
                if (activeMarkers[2]) {
                    activeMarkers[2].color = optimalColors.marker2;
                    activeMarkers[2].textColor = generateTextColor(optimalColors.marker2);
                } else {
                    activeMarkers[2] = {
                        label: '会議日',
                        color: optimalColors.marker2,
                        textColor: generateTextColor(optimalColors.marker2),
                        active: false
                    };
                }
                
                if (activeMarkers[3]) {
                    activeMarkers[3].color = optimalColors.marker3;
                    activeMarkers[3].textColor = generateTextColor(optimalColors.marker3);
                } else {
                    activeMarkers[3] = {
                        label: 'イベント',
                        color: optimalColors.marker3,
                        textColor: generateTextColor(optimalColors.marker3),
                        active: false
                    };
                }
                
                const marker1Color = document.getElementById('marker1Color');
                const marker1Preview = document.getElementById('marker1Preview');
                if (marker1Color && marker1Preview) {
                    marker1Color.value = optimalColors.marker1;
                    marker1Preview.style.backgroundColor = optimalColors.marker1;
                }
                
                const marker2Color = document.getElementById('marker2Color');
                const marker2Preview = document.getElementById('marker2Preview');
                if (marker2Color && marker2Preview && activeMarkers[2].active) {
                    marker2Color.value = optimalColors.marker2;
                    marker2Preview.style.backgroundColor = optimalColors.marker2;
                }
                
                const marker3Color = document.getElementById('marker3Color');
                const marker3Preview = document.getElementById('marker3Preview');
                if (marker3Color && marker3Preview && activeMarkers[3].active) {
                    marker3Color.value = optimalColors.marker3;
                    marker3Preview.style.backgroundColor = optimalColors.marker3;
                }
                
                applyMarkerStyles();
            });
        }

        function rgbToHex(rgb) {
            if (rgb.startsWith('#')) return rgb;
            
            const matches = rgb.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
            if (!matches) return '#000000';
            
            const r = parseInt(matches[1]);
            const g = parseInt(matches[2]);
            const b = parseInt(matches[3]);
            
            return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        }

        function updatePreview() {
            const optimalColors = generateOptimalMarkerColors(currentColors.primary);
            document.getElementById('previewPrimary').style.backgroundColor = currentColors.primary;
            document.getElementById('previewAccent').style.backgroundColor = optimalColors.marker1;
            document.getElementById('previewDark').style.backgroundColor = currentColors.hover;
        }

        document.addEventListener('click', function(e) {
            if (e.target === document.getElementById('settingsModal')) {
                document.getElementById('settingsModal').style.display = 'none';
            }
            if (e.target === document.getElementById('instagramModal')) {
                document.getElementById('instagramModal').style.display = 'none';
            }
        });
    </script>
</body>
</html>
